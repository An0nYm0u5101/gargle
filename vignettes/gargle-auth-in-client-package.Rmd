---
title: "How to use gargle for auth in a client package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use gargle for auth in a client package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

gargle provides common infrastructure for use with Google APIs. This vignette describes one possible design for using gargle to deal with auth, in a client package that provides a high-level wrapper for a specific API. There are frequent references to (the development version of) [googledrive](https://googledrive.tidyverse.org), which is a functioning test bed.

## Key choices

Getting a token requires several pieces of information, so let's review them, with an eye towards the responsibilities of the package author versus the user.

  * Overall config: Where do the OAuth app and API key come from?
  * Token-level properties: Google identity (email) and scopes.
  * Request-level

### OAuth app

Most users should present OAuth user credentials to Google APIs. However, most users can also be spared almost all the fiddly details surrounding this. The OAuth app is one example. The app is a component that most users do not even know about and they will use the same app for all work through a client package: probably, the app built into the package.

A client package can use an internal object of class `gargle::AuthClass` to hold the auth state. Here's how it is initialized in googledrive:

```{r eval = FALSE}
.auth <- gargle::AuthState$new(
  package     = "googledrive",
  app         = gargle::tidyverse_app(),     # YOUR PKG SHOULD USE ITS OWN APP!
  api_key     = gargle::tidyverse_api_key(), # YOUR PKG SHOULD USE ITS OWN KEY!
  auth_active = TRUE,
  cred        = NULL
)
```

There is a field to hold the OAuth `app`, which should default to the package's built-in app. Auth helpers, like `drive_oauth_app()` and `googledrive::drive_auth_config()`, make the current app inspectable and configurable for the minority of users who need that level of control.

```{r, eval = FALSE}
library(googledrive)

google_app <- httr::oauth_app(
  "acme-corp",
  key = "123456789.apps.googleusercontent.com",
  secret = "abcdefghijklmnopqrstuvwxyz"
)
drive_auth_config(app = google_app)

drive_oauth_app()
#> <oauth_app> acme-corp
#>   key:    123456789.apps.googleusercontent.com
#>   secret: <hidden>
```

### API key

Some Google APIs can be used in an unauthenticated state, if and only if requests include an API key. For example, this is a great way to read a Google Sheet that is world-readable or readable by "anyone with a link" from a Shiny app, without having to do any auth at all!

If you are wrapping an API with this feature, a default API key can be stored in a field of the internal auth state mentioned above. And again, auth helpers, like `googledrive::drive_auth_config()` and `drive_api_key()`, can make the current key inspectable and configurable, for the minority of users who need that level of control.

```{r, eval = FALSE}
library(googledrive)

google_app <- httr::oauth_app(
  "acme-corp",
  key = "123456789.apps.googleusercontent.com",
  secret = "abcdefghijklmnopqrstuvwxyz"
)
drive_auth_config(app = google_app)

drive_oauth_app()
#> <oauth_app> acme-corp
#>   key:    123456789.apps.googleusercontent.com
#>   secret: <hidden>
```

A good rule of thumb is that it's OK to include an API key if all the key does is allow users to do things via API that they would also be able to do in the browser, even **without being logged in**. In this case, Google uses the key to impose quotas and rate limits. If the API key has other implications, for example if it is used for billing purposes, then clearly the client package cannot include a key and should, instead, support the user's provision of a key.

### Email or Google identity

In contrast to the OAuth app and API key, every user must express which identity they wish to present to the API. This is a familiar concept and users expect to specify this. Since users may have more than one Google account, it's quite likely that they will want to switch between accounts, even within a single R session, or that they might want to explicitly declare the identity to be used in a specific script or app.

In googledrive, the main user-facing auth function is `googledrive::drive_auth()` and `email` is an optional argument that lets users proactively specify their identity. `drive_auth()` is usually called indirectly upon first need, but a user can also call it directly in order to specify their target `email`:

```{r eval = FALSE}
drive_auth(email = "janedoe_work@gmail.com")
```

If `email` is not given, gargle also checks for an option named "gargle_oauth_email". The `email` is used to look up tokens in the cache and, if no suitable token is found, it is used to pre-configure the OAuth chooser in the browser.

### Scopes

Most users have no concept of scopes. They just know they want to work with, e.g., Google Drive or Google Sheets. A client package can usually pick sensible default scopes, that will support what most users want to do.

Here's the full signature of `googledrive::drive_auth()`, mentioned above, which reveals its defaults:

```{r, eval = FALSE}
drive_auth <- function(email = NULL,
                       path = NULL,
                       scopes = "https://www.googleapis.com/auth/drive",
                       cache = gargle::gargle_oauth_cache(),
                       use_oob = gargle::gargle_oob_default()) { ... }
```

This means that a motivated user could call `drive_auth()` pre-emptively at the start of the session and request different scopes, such as `drive.readonly`, if they intend to only read data and want to guard against inadvertent file modification.

### OAuth cache and Out-of-bounds auth

These are two aspects of OAuth where most users will want sensible default behaviour. For those who want to exert control, that can be done in direct calls to `drive_auth()` or by configuring an option.

## Overview

  1. Add gargle to your package's `Imports`.
  1. Create an internal `gargle::AuthClass` object to hold auth state.
  1. Define standard functions for the auth interface between gargle and your package, somewhere such as `R/YOURPKG_auth.R`. Example: [`tidyverse/googledrive/R/drive_auth.R`](https://github.com/tidyverse/googledrive/blob/master/R/drive_auth.R)
  1. Use the functions `YOURPKG_api_key()` and `YOURPKG_token()` (defined in the standard auth interface) to insert an API key or token in your package's requests.
  1. You or your user can take greater control of auth via `YOURPKG_auth_config()`, `YOURPKG_auth()`, and `YOURPKG_deauth()` (also defined in the standard auth interface).

## Initialize package auth state

The internal object `.auth` holds the auth state of your package. Here's how that looks for googledrive:

```{r eval = FALSE}
.auth <- gargle::AuthState$new(
  package     = "googledrive",
  app         = gargle::tidyverse_app(),
  api_key     = gargle::tidyverse_api_key(),
  auth_active = TRUE,
  cred        = NULL
)
```

This is the initial state whenever googledrive is loaded and is updated during a user's session. The `.auth` object lives in the googledrive namespace. It's an instance of the `AuthState` R6 class provided by gargle.

Review of `.auth`'s fields:

  * `package`. Package name.
  * `app`. The OAuth app. Most client packages will ship with a default app, for the sake of usability.
    - The googledrive package delegates back to a default tidyverse app provided by gargle. Only packages maintained within the [`tidyverse`](https://github.com/tidyverse) or [`r-lib`](https://github.com/r-lib) GitHub organizations should use this app.
    - Other packages should substitute their default app here.
  * `api_key`. An API key is necessary to send anonymous requests for public resources, i.e., it's generally sent with requests that lack a token.
    - The relevance of the API key varies considerably across Google APIs.
    - As with the app, only packages maintained within the [`tidyverse`](https://github.com/tidyverse) or [`r-lib`](https://github.com/r-lib) GitHub organizations should use the tidyverse key.
    - Other packages should substitute their own API key here.
  * `auth_active`. When `TRUE`, googledrive makes authorized requests on behalf of an authenticated user and sends a token. When `FALSE`, googledrive sends an API key and no token.
  * `cred` holds the current credential.
    
## Getting that first token

I'm focusing on early use, by the naive user, with the OAuth flow. When the user first calls a high-level googledrive function such as `drive_find()`, a Drive request is ultimately generated with `googledrive::request_generate(..., key = NULL, token = drive_token())`. 

In the body, the API key is set like so:

```{r eval = FALSE}
params$key <- key %||% params$key %||% drive_api_key()
```

The ability to pass the key directly or as a query parameter is only available to those using googledrive's low-level API. This is not exposed in high-level functions, which, instead, can only access the current auth config. In this case, the key is obtained from the config via `drive_api_key()` but, ultimately, does not matter, since we're going to get a token and we never send both.

Here's the definition of `drive_token()`:

```{r}
drive_token <- function() {
  if (isFALSE(.auth$auth_active)) {
    return(NULL)
  }
  if (is.null(.auth$cred)) {
    drive_auth()
  }
  httr::config(token = .auth$cred)
}
```

By default, auth is active, so this will result in a call to `drive_auth()` to obtain a credential, which is then cached in `.auth$cred` for the remainder of the session.
    
## Auth interface

The exported functions like `drive_auth()`, `drive_token()`, etc. constitute the auth interface between googledrive and gargle and are centralized in [`tidyverse/googledrive/R/drive_auth.R`](https://github.com/tidyverse/googledrive/blob/master/R/drive_auth.R). That is a good template for how to use gargle to manage auth in a client package. In addition, the docs for these gargle-backed functions are generated automatically from standard information maintained in the gargle package.

  * `drive_token()` retrieves the current credential, in a form that is ready for inclusion in HTTP requests. If `auth_active` is `TRUE` and `cred` is `NULL`, `drive_auth()` is called to obtain a credential. If `auth_active` is `FALSE`, `NULL` is returned; client packages should be designed to fall back to including an API key in affected HTTP requests.
  * `drive_auth()` ensures we are dealing with an authenticated user and have a credential on hand with which to place authorized requests. Sets `auth_active` to `TRUE`. Can be called directly, but `drive_token()` will call when/as needed.
  * `drive_deauth()` sets `auth_active` to `FALSE`.
  * `drive_oauth_app()` returns `.auth$app`.
  * `drive_api_key()` returns `.auth$key`.
  * `drive_auth_config()` can be used to query and set auth config. This is how an advanced user would enter their own OAuth app and API key into auth config, in order to affect all subsequent requests.

## De-activating auth

`drive_deauth()` can be used at any time to enter a de-authorized state, during which requests are sent out with an API key and no token. This is a great way to eliminate any friction re: auth if there's no need for it, i.e. if all requests are for resources that are world readable or available to anyone who knows how to ask for it, such as files shared via "Anyone with the link". The de-authorized state is especially useful in non-interactive settings or where user interaction is indirect, such as via Shiny.

## BYOAK = Bring Your Own App and Key

Advanced users can use their own OAuth app and API key. `drive_auth_config()` lives in `R/drive_auth()` and it provides the ability to see or modify the current `app` and `api_key`. Recall that `drive_oauth_app()` and `drive_api_key()` also exist for targeted, read-only access.

## Changing identities (and more)

One reason for a user to call `drive_auth()` directly and proactively is to switch from one Google identity to another or to make sure they are presenting themselves with a specific identity. `drive_auth()` accepts an `email` argument, which is honored when gargle determines if there is already a suitable token on hand.

`drive_auth()` gives the motivated user more control:

  * `email`: Specify a Google identity.
  * `path`: Provide a service account token.
  * `scopes`: Request, for example, a narrower scope that is read-only.
  * `cache`: Control whether gargle uses a token cache.
  * `use_oob`: Toggle out-of-band authentication.
